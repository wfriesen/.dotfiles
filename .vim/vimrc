runtime bundle/vim-pathogen/autoload/pathogen.vim
execute pathogen#infect()

" Pretty colors
syntax on
filetype plugin indent on
set background=dark
colorscheme solarized

highlight LineNr guifg=#586e75 ctermfg=10
highlight CursorLineNr guifg=#839496 ctermfg=12
highlight Cursor guibg=#dc322f

if has('win32')
  set guifont=Hack:h12
else
  set guifont=Hack\ 16
endif

set lazyredraw " Execute macros faster by not redrawing the screen constantly

set number
set relativenumber
set cursorline

" remove some gvim clutter
set guioptions-=m "menubar
set guioptions-=r "scrollbar
set guioptions-=T "toolbar
set guioptions-=L "Left-hand scrollbar

set backspace=indent,eol,start " Make backspace work like expected

set hidden " Allow hidden buffers with unsaved changes

" Formatting options
set fileformats=unix,dos
set encoding=utf-8
set tabstop=2
set softtabstop=0
set expandtab
set shiftwidth=2
set smarttab
set autoindent

" Ignore case, except if the entered search pattern contains upper case chars
set ignorecase
set smartcase

set incsearch " Search as you type. <Esc> still cancels and returns
set gdefault " Always use /g for :s commands
set virtualedit=block " In visual block mode, allow the cursor to move anywhere
set backupcopy=yes " Let's webpack pick up changes
set showmode " Show the mode in command line. Airline shows it anyway, but it's just be empty otherwise

set laststatus=2 " Always show status line

set wildmenu " Show matches when invoking command line completion

" Exclude these folders from ctrlp
set wildignore+=*/node_modules/*
set wildignore+=*/$tf/*

set isfname-=@-@ " Strip out @ from file names. Useful for sqlplus files that call others with @@filename.sql

set sessionoptions-=options " Keeping this on seems to break loading sessions when using plugins

set completeopt=
set completeopt+=menu " Use popup menu, even if there's only one match
set completeopt+=menuone " Show even when there's only one match
set completeopt+=preview " Show some extra info (types, filenames, etc)

" Persistent undo history
set undofile
set undodir=~/.vim/undo

let g:netrw_liststyle=1 " Show file size and modification times

" Use space as leader
nnoremap <Space> <Nop>
let mapleader = "\<Space>"

" Make * and # in visual mode work like in normal mode
vnoremap <silent> * "zy/<C-R>z<CR>
vnoremap <silent> # "zy?<C-R>z<CR>

" Use Alt- for scrolling
nnoremap <A-l> zl
nnoremap <A-h> zh
nnoremap <A-L> 100zl
nnoremap <A-H> 100zh
nnoremap <A-j> <C-e>
nnoremap <A-k> <C-y>
nnoremap <A-J> <C-d>
nnoremap <A-K> <C-u>

" Copy/paste to system clipboard with <C-c>
if has('win32')
  let g:clipboard_register="*"
else
  let g:clipboard_register="+"
endif
execute "vnoremap <silent> <C-c> \"" . g:clipboard_register . "y"
execute "inoremap <silent> <C-v> <C-R>" . g:clipboard_register
" Yank to the system clipboard, can be used like <C-c>i( or <C-c>t$ etc.
execute "nmap <silent> <C-c> \"" . g:clipboard_register . "y"

" Wrap a paragraph in an inline view, limiting with "where rownum <= 10".
function! g:WrapInRowLimiter()
  :execute ":normal! mz{owith q as ("
  :normal! j>/^\/
  :normal! /^/nO)select	*from qwhere rownum <= 10
  :normal! `zll
endfunction
nmap <silent> <leader>lr :call g:WrapInRowLimiter()<CR>

nmap <silent> <leader>u :UndotreeToggle<CR>
nmap <silent> <leader>t :TagbarToggle<CR>
nmap [c <Plug>GitGutterPrevHunk
nmap ]c <Plug>GitGutterNextHunk

" VORAX. Jump to the header row of the output window
" can then jump to the next/previous column with ; and ,
nmap <silent> <leader>H gg/^\( \)\?-<CR>kztjf<Space>

nmap <silent> <C-Enter> :VORAXExecCurrent<CR>
nmap <silent> <F5> :VORAXCompile<CR>
imap <silent> <C-Enter> <Esc>:VORAXExecCurrent<CR>

" Open CtrlP and put the current word in the prompt
map <leader><C-P> <C-P><C-\>w

let g:undotree_SetFocusWhenToggle=1 " Focus the undotree window when opening

" Don't let vorax clobber this mapping
let g:vorax_key_connections_toggle='<leader>vpr'
" Temporarily switch to the home directory when opening the VORAX connections
" window, so that it can find profiles.xml
function! g:ToggleVORAXConnections()
  if bufwinnr('__VORAX_CONNECTIONS__') == -1
    :execute ':cd ~'
    :execute ':VORAXConnectionsToggle'
    :execute ':cd -'
  else
    :execute ':VORAXConnectionsToggle'
  endif
endfunction
nmap <silent> <leader>pr :call g:ToggleVORAXConnections()<CR>

" start gvim maximized. Simulates pressing Alt+Space x
if has('win32')
  autocmd GUIEnter * simalt ~x
endif

let g:startify_enable_special = 0 " Show <empty buffer> and <quit>
let g:startify_session_sort = 1 " Sort sessions by modification time
let g:startify_fortune_use_unicode = 1 " Nicer border than the default ASCII
let g:startify_session_dir = '~/.vim/session' " Don't let it override to $HOME\vimfiles\session for Windows

" Show sessions at the top. Pressing CR immediately after starting loads the
" latest session
let g:startify_list_order = [
        \ ['   Sessions'],
        \ 'sessions',
        \ ['   MRU Files'],
        \ 'files',
        \ ['   MRU in CWD'],
        \ 'dir',
        \ ]

" Use /*..*/ style comments instead of --
autocmd FileType sql setlocal commentstring=/\*\ %s\ \*/

" Change order to put variables at the top, since that's usually where they are
" defined anyway
let g:tagbar_type_sql = {
    \ 'kinds' : [
        \ 'P:packages:1',
        \ 'v:variables',
        \ 'd:prototypes',
        \ 'c:cursors',
        \ 'f:functions',
        \ 'F:record fields',
        \ 'L:block label',
        \ 'p:procedures',
        \ 's:subtypes',
        \ 't:tables',
        \ 'T:triggers',
        \ 'i:indexes',
        \ 'e:events',
        \ 'U:publications',
        \ 'R:services',
        \ 'D:domains',
        \ 'V:views',
        \ 'n:synonyms',
        \ 'x:MobiLink Table Scripts',
        \ 'y:MobiLink Conn Scripts',
        \ 'z:MobiLink Properties',
    \ ],
\ }
let g:tagbar_compact=1 " Don't show help, just tags
let g:tagbar_autofocus=1 " Focus tagbar when opening
let g:tagbar_sort=0 " Sort by file position, not alphabetically
let g:tagbar_width=30

let g:AutoPairsCenterLine=0 " Don't do zz after CR

let g:vorax_output_window_size=20
let g:vorax_dbexplorer_size=32
let g:vorax_cmanager_size=30

let g:vorax_key_describe='<F4>'
let g:vorax_key_describe_verbose='<S-F4>'

let g:vorax_output_full_heading=1 " Set VORAX output window to show full headings

let g:vorax_output_show_open_txn=1 " Show marker in status line when in an open transaction

let g:vorax_plsql_associations=
\ {'FUNCTION' : 'fnc',
\  'PROCEDURE' : 'prc',
\  'TRIGGER' : 'trg',
\  'PACKAGE_SPEC' : 'pks',
\  'PACKAGE_BODY' : 'pkb',
\  'PACKAGE' : 'pkg',
\  'TYPE_SPEC' : 'tps',
\  'TYPE_BODY' : 'tpb',
\  'TYPE' : 'typ',
\  'JAVA_SOURCE' : 'jsp'}

let g:ctrlp_working_path_mode='ra' " Start ctrlp from the VCS root (r). Fallback to directory of current file (a)
let g:ctrlp_clear_cache_on_exit=0 " Keep the cache across sessions
let g:ctrlp_open_multiple_files='t' " Open multiple files in tabs, rather than new splits
let g:ctrlp_types = ['fil', 'mru', 'buf'] " Re-order modes. After opening CtrlP, <C-b> now jumps to 'Buffers'

let g:SuperTabCrMapping=1 " Finish completion with CR
let g:SuperTabClosePreviewOnPopupClose=1
"
" Use omni-completion when possible
let g:SuperTabDefaultCompletionType="context"
autocmd FileType *
  \ if &omnifunc != '' |
  \   call SuperTabChain(&omnifunc, "<c-p>") |
  \ endif

let g:airline_theme='tomorrow'
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_close_button = 0 " Turn off the X to close a tab
let g:airline#extensions#tabline#show_tabs = 1
let g:airline#extensions#tabline#show_splits = 1
let g:airline#extensions#tabline#tab_nr_type = 2 " Show # of splits and tab number

" Reset some plugin windows to their defined sizes.
let g:plugin_window_types_resize_cmd = {
\ 'connvorax': 'vertical resize' . g:vorax_cmanager_size,
\ 'explorervorax': 'vertical resize' . g:vorax_dbexplorer_size,
\ 'outputvorax': 'resize' . g:vorax_output_window_size,
\ 'tagbar': 'vertical resize' . g:tagbar_width
\ }
function! g:ResizeAllPluginWindows()

  function! s:ResizePluginWindows()
    if has_key(g:plugin_window_types_resize_cmd, &ft)
      :execute g:plugin_window_types_resize_cmd[&ft]
    endif
  endfunction

  let currentWindow = winnr()
  :windo call s:ResizePluginWindows()
  :execute currentWindow . 'wincmd w'

endfunction
nmap <silent> <leader>r :call g:ResizeAllPluginWindows()<CR>
