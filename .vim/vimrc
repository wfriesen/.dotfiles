" Has to be set before colorscheme, so that lightline picks up it's own colorscheme setting
let g:lightline = {'colorscheme': 'solarized'}

runtime bundle/vim-pathogen/autoload/pathogen.vim

" Don't load vorax in Cygwin. It doesn't work, and just slows down lightline
if has('win32unix')
  set wildignore+=*/vorax4
  execute pathogen#infect()
  set wildignore-=*/vorax4
else
  execute pathogen#infect()
endif

set showtabline=2 " Always show the tabline

" Pretty colors
syntax on
filetype plugin indent on
set background=dark
colorscheme solarized

highlight LineNr guifg=#586e75 ctermfg=10
highlight CursorLineNr guifg=#839496 ctermfg=12
highlight Cursor guibg=#dc322f

if has('win32')
  set guifont=Hack:h12
else
  set guifont=Hack\ 16
endif

set lazyredraw " Execute macros faster by not redrawing the screen constantly

set number
set relativenumber
set cursorline

if has('gui_running')
  set guioptions-=m "menubar
  set guioptions-=r "scrollbar
  set guioptions-=T "toolbar
  set guioptions-=L "Left-hand scrollbar
  set guioptions+=c "Use console dialogs for simple choices
  set guioptions-=e
  set guicursor+=a:block " Always use block cursor in GUI mode
endif

set backspace=indent,eol,start " Make backspace work like expected

set hidden " Allow hidden buffers with unsaved changes

" Formatting options
set fileformats=unix,dos
set encoding=utf-8
set tabstop=2
set softtabstop=0
set expandtab
set shiftwidth=2
set shiftround " round indents to multiples of shiftwidth
set smarttab
set autoindent

" Ignore case, except if the entered search pattern contains upper case chars
set ignorecase
set smartcase

set hlsearch " Highlight search matches
set incsearch " Search as you type. <Esc> still cancels and returns
set gdefault " Always use /g for :s commands
set virtualedit=block " In visual block mode, allow the cursor to move anywhere
set backupcopy=yes " Let's webpack pick up changes
set showmode " Show the mode in command line. statusline shows it anyway, but it'd just be empty otherwise

set laststatus=2 " Always show status line

set wildmenu " Show matches when invoking command line completion
set wildignorecase " Case insensitive filename matching

" Exclude these folders from ctrlp
set wildignore+=*/node_modules/*
set wildignore+=*/$tf/*

set isfname-=@-@ " Strip out @ from file names. Useful for sqlplus files that call others with @@filename.sql

set sessionoptions-=options " Keeping this on seems to break loading sessions when using plugins

set completeopt=
set completeopt+=menu " Use popup menu, even if there's only one match
set completeopt+=menuone " Show even when there's only one match
set completeopt+=preview " Show some extra info (types, filenames, etc)

if has('win32') && has('gui_running')
  if expand('$CYGWIN_PATH') == '$CYGWIN_PATH'
    echoerr "$CYGWIN_PATH must be set when running from windows"
  else
    let s:cygwin_home = expand('$CYGWIN_PATH/home/$USERNAME')
  endif
endif

" Store persistent undo history in the same place across gvim and cygwin vim
" Requires Windows to have the $CYGWIN_PATH variable set manually
set undofile
if has('win32') && has('gui_running')
  let &undodir = expand(s:cygwin_home.'\.vim\undo')
else
  let &undodir = expand('$HOME/.vim/undo')
endif

let g:netrw_liststyle=1 " Show file size and modification times

" Use space as leader
nnoremap <Space> <Nop>
let mapleader = "\<Space>"

set cedit=<C-l> " Open the command-line window

" Set to defaults, so that later appends in this file won't constantly
" increase it
set viminfo='100,<50,s10,h,rA:,rB:

" Move cursor in command line mode just like in bash and others. C-e and C-k are
" already mapped by default to move to, and delete until, the end of the line
cnoremap <C-a> <Home>
cnoremap <A-b> <C-Left>
cnoremap <A-f> <C-Right>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-k> <C-\>estrpart(getcmdline(),0,getcmdpos()-1)<CR>

" Toggle search highlighting
nmap <silent> <leader>hl :set hlsearch!<CR>

" Don't use word boundaries for * and #
nnoremap * g*
nnoremap # g#
" g* and g# for word boundaries
nnoremap g* *
nnoremap g# #

" Make * and # in visual mode work like in normal mode
vnoremap <silent> * "zy/<C-R>z<CR>
vnoremap <silent> # "zy?<C-R>z<CR>

" Shift and Control insensitive mapping
nnoremap <C-w>t <C-w>T
nnoremap <C-w><C-t> <C-w>T

" Use Alt- for scrolling
if has('gui_running')
  let s:alt_key_prefix="<A-"
  let s:alt_key_suffix=">"
else
  let s:alt_key_prefix=""
  let s:alt_key_suffix=""
endif
execute "nnoremap ".s:alt_key_prefix."l".s:alt_key_suffix." zl"
execute "nnoremap ".s:alt_key_prefix."h".s:alt_key_suffix." zh"
execute "nnoremap ".s:alt_key_prefix."L".s:alt_key_suffix." 100zl"
execute "nnoremap ".s:alt_key_prefix."H".s:alt_key_suffix." 100zh"
execute "nnoremap ".s:alt_key_prefix."j".s:alt_key_suffix." <C-e>"
execute "nnoremap ".s:alt_key_prefix."k".s:alt_key_suffix." <C-y>"
execute "nnoremap ".s:alt_key_prefix."J".s:alt_key_suffix." <C-d>"
execute "nnoremap ".s:alt_key_prefix."K".s:alt_key_suffix." <C-u>"

" Copy/paste to system clipboard with <C-c> and <C-v>
if has('win32')
  let s:clipboard_register="*"
else
  let s:clipboard_register="+"
endif
execute "vnoremap <silent> <C-c> \"" . s:clipboard_register . "y"
execute "inoremap <silent> <C-v> <C-R>" . s:clipboard_register
execute "cnoremap <C-v> <C-R>" . s:clipboard_register
" Yank to the system clipboard, can be used like <C-c>i( and the like
execute "nmap <silent> <C-c> \"" . s:clipboard_register . "y"

nmap <silent> <leader>gs :Gstatus<CR>
nmap <silent> <leader>ge :Gedit<CR>
nmap <silent> <leader>gd :Gdiff<CR>
nmap <silent> <leader>gl :GV -20<CR>
nmap <silent> <leader>gv :GV!<CR>

" Wrap a paragraph in an inline view, limiting with "where rownum <= 10".
function! g:WrapInRowLimiter()
  :execute ":normal! mz{owith q as ("
  :normal! }k
  :s/;$//
  :normal! o)select	*from qwhere rownum <= 10;
  :normal! `zll
  :execute ":normal >i("
endfunction
nmap <silent> <leader>lr :call g:WrapInRowLimiter()<CR>

" execute docmd in all windows, then return cursor to the original window
function! g:WindoReturn(docmd)
  let l:current_winnr = winnr()
  execute ":windo ".a:docmd
  execute l:current_winnr."wincmd w"
endfunction

" Fold operations on all windows in the current tab page
nnoremap <silent> <leader>zR :call g:WindoReturn(":normal zR")<CR>
nnoremap <silent> <leader>zM :call g:WindoReturn(":normal zM")<CR>
nnoremap <silent> <leader>zr :call g:WindoReturn(":normal zr")<CR>
nnoremap <silent> <leader>zm :call g:WindoReturn(":normal zm")<CR>

nmap <silent> <leader>u :UndotreeToggle<CR>
nmap <silent> <leader>t :TagbarToggle<CR>
nmap [c <Plug>GitGutterPrevHunk
nmap ]c <Plug>GitGutterNextHunk

" VORAX. Jump to the header row of the output window
" can then jump to the next/previous column with ; and ,
nmap <silent> <leader>H gg/^\( \)\?-<CR>kztjf<Space>

nmap <silent> <C-Enter> :VORAXExecCurrent<CR>
nmap <silent> <F5> :VORAXCompile<CR>
imap <silent> <C-Enter> <Esc>:VORAXExecCurrent<CR>

" Open CtrlP and put the current word in the prompt
map <leader><C-P> <C-P><C-\>w

let g:undotree_SetFocusWhenToggle=1 " Focus the undotree window when opening

" Move up/down the same way in some plugin windows
function! g:Undotree_CustomMap()
  nmap <buffer> <C-k> <plug>UndotreeGoNextState
  nmap <buffer> <C-j> <plug>UndotreeGoPreviousState
endfunc
autocmd FileType GV nmap <buffer> <C-k> <C-p>
autocmd FileType GV nmap <buffer> <C-j> <C-n>
autocmd FileType gitcommit nmap <buffer> <C-k> <C-p>
autocmd FileType gitcommit nmap <buffer> <C-j> <C-n>

" start gvim maximized. Simulates pressing Alt+Space x
if has('win32')
  autocmd GUIEnter * simalt ~x
endif

let g:startify_enable_special = 0 " Don't show <empty buffer> and <quit>
let g:startify_session_sort = 1 " Sort sessions by modification time
let g:startify_custom_header = [] " Turn off the cowsay fortune header
" Keep session and info files in the same place in windows gvim and cygwin vim
if has('win32') && has('gui_running')
  let g:startify_session_dir = s:cygwin_home.'\.vim\session'
  let g:viminfo_location = s:cygwin_home.'\.vim\.viminfo'
  let g:vorax_homedir = s:cygwin_home.'\.vim'
else
  let g:startify_session_dir = '~/.vim/session'
  let g:viminfo_location = '~/.vim/.viminfo_cygwin'
  let g:vorax_homedir = '~/.vim'
endif
let &viminfo = &viminfo . ',n' . g:viminfo_location

" Show sessions at the top. Pressing CR immediately after starting loads the
" latest session
let g:startify_list_order = [
        \ ['   Sessions'],
        \ 'sessions',
        \ ['   MRU Files'],
        \ 'files',
        \ ['   MRU in CWD'],
        \ 'dir',
        \ ]

" Use /*..*/ style comments instead of --
autocmd FileType sql setlocal commentstring=/\*\ %s\ \*/

" Change order to put variables at the top, since that's usually where they are
" defined anyway
let g:tagbar_type_sql = {
    \ 'kinds' : [
        \ 'P:packages:1',
        \ 'v:variables',
        \ 'd:prototypes',
        \ 'c:cursors',
        \ 'f:functions',
        \ 'F:record fields',
        \ 'L:block label',
        \ 'p:procedures',
        \ 's:subtypes',
        \ 't:tables',
        \ 'T:triggers',
        \ 'i:indexes',
        \ 'e:events',
        \ 'U:publications',
        \ 'R:services',
        \ 'D:domains',
        \ 'V:views',
        \ 'n:synonyms',
        \ 'x:MobiLink Table Scripts',
        \ 'y:MobiLink Conn Scripts',
        \ 'z:MobiLink Properties',
    \ ],
\ }
let g:tagbar_compact=1 " Don't show help, just tags
let g:tagbar_autofocus=1 " Focus tagbar when opening
let g:tagbar_sort=0 " Sort by file position, not alphabetically
let g:tagbar_width=30

let g:AutoPairsCenterLine=0 " Don't do zz after CR

let g:vorax_output_window_size=20
let g:vorax_dbexplorer_size=32
let g:vorax_cmanager_size=30

let g:vorax_key_describe='<F4>'
let g:vorax_key_describe_verbose='<S-F4>'

let g:vorax_output_full_heading=1 " Set VORAX output window to show full headings

let g:vorax_output_show_open_txn=1 " Show marker in status line when in an open transaction

let g:vorax_plsql_associations=
\ {'FUNCTION' : 'fnc',
\  'PROCEDURE' : 'prc',
\  'TRIGGER' : 'trg',
\  'PACKAGE_SPEC' : 'pks',
\  'PACKAGE_BODY' : 'pkb',
\  'PACKAGE' : 'pkg',
\  'TYPE_SPEC' : 'tps',
\  'TYPE_BODY' : 'tpb',
\  'TYPE' : 'typ',
\  'JAVA_SOURCE' : 'jsp'}

" Map q to quit windows
autocmd FileType connvorax,explorervorax,outputvorax,help nnoremap <buffer> q <C-w>q

let g:ctrlp_working_path_mode='ra' " Start ctrlp from the VCS root (r). Fallback to directory of current file (a)
let g:ctrlp_clear_cache_on_exit=0 " Keep the cache across sessions
let g:ctrlp_open_multiple_files='t' " Open multiple files in tabs, rather than new splits
let g:ctrlp_types = ['fil', 'mru', 'buf'] " Re-order modes. After opening CtrlP, <C-b> now jumps to 'Buffers'

let g:SuperTabCrMapping=1 " Finish completion with CR
let g:SuperTabClosePreviewOnPopupClose=1
"
" Use omni-completion when possible
let g:SuperTabDefaultCompletionType="context"
autocmd FileType *
  \ if &omnifunc != '' |
  \   call SuperTabChain(&omnifunc, "<c-p>") |
  \ endif

function! g:VoraxOutputFlags()
  let funnel = ["", "VERTICAL", "PAGEZIP", "TABLEZIP"][vorax#output#GetFunnel()]
  let append = g:vorax_output_window_append ? "APPEND" : ""
  let sticky = g:vorax_output_window_sticky_cursor ? "STICKY" : ""
  let heading = g:vorax_output_full_heading ? "HEADING" : ""
  let top = g:vorax_output_cursor_on_top ? "TOP" : ""
  return join(filter([funnel, append, sticky, heading, top], 'v:val != ""'), ' ')
endfunction

let g:lightline.active = {
      \ 'left': [
      \   [ 'mode', 'paste', 'voraxtxn' ],
      \   [ 'gitbranch', 'readonly', 'filename', 'modified' ]
      \ ],
      \ 'right': [
      \   [ 'voraxright' ],
      \   [ 'lineinfo' ],
      \   [ 'percent' ],
      \   [ 'fileformat', 'fileencoding', 'filetype' ]
      \ ]
      \ }
let g:lightline.component = {'lineinfo' : ' %3l:%-2v'}
let g:lightline.component_type = {
      \ 'voraxtxn': 'warning'
      \ }
let g:lightline.component_expand = {
      \ 'voraxtxn': 'LightlineVoraxTxn'
      \ }
let g:lightline.component_function = {
      \ 'readonly': 'LightlineReadonly',
      \ 'gitbranch': 'LightlineFugitive',
      \ 'fullfilepath': 'LightlineFullfilepath',
      \ 'voraxright': 'LightlineVoraxRight',
      \ 'filename': 'LightlineFilename'
      \ }
let g:lightline.separator = {'left': '', 'right': ''}
let g:lightline.subseparator = { 'left': '', 'right': ''}
let g:lightline.subseparator.tab = {'active': [ 'tabnum', 'filename', 'modified' ]}
let g:lightline.tabline = {
      \ 'left': [ [ 'tabs' ] ],
      \ 'right': [ [ 'fullfilepath', 'modified' ] ]
      \ }
function! LightlineReadonly()
  return &readonly ? '' : ''
endfunction
let g:ctrlp_status_func = {
      \ 'main': 'CtrlPStatusFunc_main',
      \ 'prog': 'CtrlPStatusFunc_prog',
      \ }

function! LightlineFugitive()
  if exists('*fugitive#head')
    let branch = fugitive#head()
    return branch !=# '' ? ' '.branch : ''
  endif
  return ''
endfunction

function! LightlineFilename()
  if expand('%:t') == 'ControlP'
    return g:lightline.ctrlp_prev . ' ' . g:lightline.subseparator.left . ' ' .
          \ g:lightline.ctrlp_item . ' ' . g:lightline.subseparator.left . ' ' .
          \ g:lightline.ctrlp_next
  elseif &ft == 'outputvorax'
    let l:voraxsession = vorax#sqlplus#SessionOwner()
    return l:voraxsession == '@' ? l:filename : l:voraxsession
  else
    return '' != expand('%:t') ? expand('%:t') : '[No Name]'
  endif
endfunction

function! CtrlPStatusFunc_main(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  let g:lightline.ctrlp_marked = a:marked
  return lightline#statusline(0)
endfunction
function! CtrlPStatusFunc_prog(str)
  return lightline#statusline(0)
endfunction
let g:tagbar_status_func = 'TagbarStatusFunc'
function! TagbarStatusFunc(current, sort, fname, ...) abort
  return lightline#statusline(0)
endfunction
function! LightlineFullfilepath()
  return expand('%:.')
endfunction
function! LightlineVoraxRight()
  if &ft == 'outputvorax'
    let l:limitrows = exists("g:vorax_limit_rows") ? " [LIMIT ROWS <=" . g:vorax_limit_rows . "]" : ""
    return g:VoraxOutputFlags() . l:limitrows
  else
    return ''
  endif
endfunction
function! LightlineVoraxTxn()
  if g:loaded_vorax
    return '%{vorax#utils#IsOpenTxn() ? "!" . g:vorax_output_txn_marker : ""}'
  endif
endfunction

" Reset some plugin windows to their defined sizes.
function! g:ResizePluginWindow()
  let l:plugin_window_types_resize_cmd = {
  \ 'connvorax': 'vertical resize' . g:vorax_cmanager_size,
  \ 'explorervorax': 'vertical resize' . g:vorax_dbexplorer_size,
  \ 'outputvorax': 'resize' . g:vorax_output_window_size,
  \ 'tagbar': 'vertical resize' . g:tagbar_width
  \ }

  if has_key(l:plugin_window_types_resize_cmd, &ft)
    :execute l:plugin_window_types_resize_cmd[&ft]
  endif
endfunction
nmap <silent> <leader>r :call g:WindoReturn(":call g:ResizePluginWindow()")<CR>
